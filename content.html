<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Contenta</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      min-height: 100vh;
      background: #020617;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont;
      padding: 1.5rem;
    }

    h1 {
      text-align: center;
      margin-bottom: 0.3rem;
      font-size: 1.6rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .subtitle {
      text-align: center;
      font-size: 0.85rem;
      opacity: 0.8;
      margin-bottom: 1rem;
    }

    .description {
      text-align: center;
      font-size: 0.9rem;
      margin-bottom: 1rem;
      opacity: 0.9;
    }

    .media-type-selector {
      text-align: center;
      margin-bottom: 1.5rem;
    }

    .media-type-selector select {
      padding: 0.5rem;
      border-radius: 8px;
      border: 1px solid #1e293b;
      background: #0f172a;
      color: #e5e7eb;
      margin-right: 0.5rem;
    }

    .media-type-selector button {
      padding: 0.5rem 1rem;
      border-radius: 8px;
      border: none;
      background: #1e293b;
      color: #e5e7eb;
      cursor: pointer;
    }

    .media-type-selector button:hover {
      background: #334155;
    }

    .grid-container {
      display: flex;
      flex-wrap: wrap;
      gap: 2rem;
      max-width: 1200px;
      margin: auto;
    }

    .grid-section {
      flex: 1;
      min-width: 300px;
    }

    .grid-section h2 {
      text-align: center;
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: #38bdf8;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
    }

    .card {
      background: linear-gradient(135deg, #0f172a, #020617);
      border: 1px solid #1e293b;
      border-radius: 14px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      transition: transform 0.15s ease;
    }

    .card:hover {
      transform: scale(1.02);
    }

    .title {
      font-size: 0.9rem;
      font-weight: 600;
      word-break: break-all;
      color: #38bdf8;
    }

    .meta {
      font-size: 0.75rem;
      color: #94a3b8;
      line-height: 1.4;
    }

    .open-btn {
      margin-top: auto;
      padding: 0.6rem;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      background: #1e293b;
      color: #e5e7eb;
      font-weight: 500;
    }

    .open-btn:hover {
      background: #334155;
    }

    .status {
      text-align: center;
      opacity: 0.85;
      margin-top: 2rem;
      font-size: 0.9rem;
    }

    .back {
      display: block;
      text-align: center;
      margin-bottom: 1rem;
      color: #93c5fd;
      text-decoration: none;
      font-size: 0.9rem;
    }
    
    .reviews-link {
      color: #60a5fa;
      text-decoration: none;
    }
    
    .reviews-link:hover {
      text-decoration: underline;
    }

    /* Fullscreen overlay styles */
    .fullscreen-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 1000;
      display: flex;
      flex-direction: column;
    }

    .close-btn {
      position: fixed;
      top: 15px;
      right: 15px;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(255, 0, 0, 0.3); /* Light transparent red */
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      z-index: 1001;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .close-btn:hover {
      background: rgba(255, 0, 0, 0.5);
    }

    .embed-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .embed-container iframe {
      width: 100vw;
      height: 100vh;
      border: none;
    }
    
    .share-btn {
      background: none;
      border: none;
      color: #60a5fa;
      cursor: pointer;
      font-size: 1.2rem;
      padding: 0;
      margin-left: 0.5rem;
    }
    
    .share-btn:hover {
      color: #93c5fd;
    }
    
    .profile-link {
      color: #60a5fa;
      text-decoration: none;
      margin-left: 5px;
      cursor: pointer;
    }
    
    .profile-link:hover {
      text-decoration: underline;
    }
    
    .preview-container {
      height: 200px; /* Increased height */
      margin: 5px 0;
      border-radius: 8px;
      overflow: hidden;
    }
    
    .preview-placeholder {
      height: 100%;
      background: #020617;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #64748b;
      font-size: 0.8rem;
    }
    
    .preview-container img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .card-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: auto;
      align-items: center;
    }
    
    .username-meta {
      font-size: 0.75rem;
      color: #93c5fd;
      line-height: 1.4;
    }
    
    .description-full {
      font-size: 0.75rem;
      color: #cbd5e1;
      line-height: 1.5;
      margin-top: 0.5rem;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    .load-more-btn {
      display: block;
      margin: 2rem auto;
      padding: 0.8rem 1.5rem;
      border-radius: 10px;
      border: none;
      background: #1e293b;
      color: #e5e7eb;
      font-weight: 500;
      cursor: pointer;
    }
    
    .load-more-btn:hover {
      background: #334155;
    }
    
    .hidden {
      display: none;
    }
  </style>
</head>
<body>

  <a class="back" href="index.html">‚Üê Back to Dashboard</a>
  <h1>
    <span>üìö</span> Contenta
  </h1>
  <div class="description">A place to learn, enjoy, feel, express‚Äîwhile knowing others and being active together.</div>
  
  <div class="media-type-selector">
    <label for="mediatype">Media Type:</label>
    <select id="mediatype">
      <option value="all">All Types</option>
      <option value="texts">Texts</option>
      <option value="movies">Movies</option>
      <option value="audio">Audio</option>
      <option value="software">Software</option>
      <option value="image">Images</option>
      <option value="data">Data</option>
      <option value="web">Web</option>
      <option value="collection">Collections</option>
      <option value="account">Accounts</option>
    </select>
    <button id="filter-btn">OK</button>
  </div>

  <div class="subtitle" id="subtitle"></div>

  <div class="grid-container">
    <div class="grid-section">
      <h2>Profile Items & Identifiers</h2>
      <div class="grid" id="grid"></div>
    </div>
  </div>

  <button id="load-more" class="load-more-btn">Load More</button>
  <div class="status" id="status">Initializing‚Ä¶</div>

  <script>
    const grid = document.getElementById("grid");
    const status = document.getElementById("status");
    const subtitle = document.getElementById("subtitle");
    const mediatypeSelect = document.getElementById("mediatype");
    const filterBtn = document.getElementById("filter-btn");
    const loadMoreBtn = document.getElementById("load-more");

    // Store all items for filtering
    let allItems = [];
    let currentFilter = "all";
    let loadedCount = 0;
    const ITEMS_PER_LOAD = 9;
    
    // Store identifiers for later insertion
    let identifierItems = [];
    let allIdentifiers = []; // Combined list of identifiers
    let identifierIndex = 0; // Track which identifiers we've used
    
    // Cache for metadata
    const metadataCache = new Map();
    const thumbnailCache = new Map();

    // Get thumbnail URL
    function getThumbnailUrl(identifier) {
      return `https://archive.org/services/img/${identifier}`;
    }

    // IntersectionObserver for lazy loading thumbnails
    const thumbnailObserver = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (!entry.isIntersecting) return;

        const container = entry.target;
        const identifier = container.dataset.identifier;
        
        if (thumbnailCache.has(identifier)) {
          container.innerHTML = `<img src="${thumbnailCache.get(identifier)}" alt="Thumbnail" loading="lazy">`;
        } else {
          const imgUrl = getThumbnailUrl(identifier);
          const img = document.createElement('img');
          img.src = imgUrl;
          img.alt = "Thumbnail";
          img.loading = "lazy";
          
          img.onload = () => {
            thumbnailCache.set(identifier, imgUrl);
          };
          
          container.innerHTML = '';
          container.appendChild(img);
        }

        thumbnailObserver.unobserve(container);
      });
    }, {
      rootMargin: "200px",
      threshold: 0.1
    });

    const stored = localStorage.getItem("archive_profile_urls");
    if (!stored) {
      status.textContent = "No archive data found.";
      throw new Error("Missing localStorage");
    }

    let profileUrls = JSON.parse(stored);
    if (!profileUrls.length) {
      status.textContent = "Archive list is empty.";
      throw new Error("Empty list");
    }

    // üé≤ Shuffle profiles (random order, no repeats)
    profileUrls = profileUrls
      .map(v => ({ v, r: Math.random() }))
      .sort((a, b) => a.r - b.r)
      .map(o => o.v);

    function extractUsername(url) {
      const match = url.match(/@([^/]+)/);
      return match ? match[1] : null;
    }

    // Account state tracking
    let accountState = {};
    let usedThisRound = new Set();
    // Store username mapping
    let usernameMap = {};

    profileUrls.forEach(url => {
      const username = extractUsername(url);
      if (username) {
        usernameMap[url] = username;
      }
      accountState[url] = {
        page: 1,
        total: null,
        exhausted: false
      };
    });

    function pickRandomAccount() {
      const available = profileUrls.filter(
        u => !usedThisRound.has(u) && !accountState[u].exhausted
      );

      if (!available.length) {
        usedThisRound.clear(); // start next round
        return pickRandomAccount();
      }

      const pick = available[Math.floor(Math.random() * available.length)];
      usedThisRound.add(pick);
      return pick;
    }

    async function fetchThreeLatest(profileUrl) {
      const username = usernameMap[profileUrl];
      const state = accountState[profileUrl];
      if (state.exhausted) return null;

      const api =
        `https://archive.org/advancedsearch.php` +
        `?q=creator:@${username}` +
        `&fl[]=identifier` +
        `&fl[]=title` +
        `&fl[]=creator` +
        `&fl[]=publicdate` +
        `&fl[]=mediatype` +
        `&fl[]=description` +
        `&fl[]=subject` +
        `&sort[]=publicdate desc` +
        `&rows=3` +
        `&page=${state.page}` +
        `&output=json`;

      const res = await fetch(api);
      const data = await res.json();

      if (state.total === null) {
        state.total = data.response.numFound;
      }

      if (!data.response.docs.length) {
        state.exhausted = true;
        return null;
      }

      state.page++;
      // Return both docs and the username
      return {
        docs: data.response.docs,
        username: username
      };
    }

    // Fetch metadata using Archive.org metadata API with caching
    async function fetchIdentifierMetadata(identifier) {
      if (metadataCache.has(identifier)) {
        return metadataCache.get(identifier);
      }

      try {
        const response = await fetch(`https://archive.org/metadata/${identifier}`);
        const data = await response.json();
        
        if (data.metadata) {
          // Use metadata from the metadata API response
          const metadata = {
            identifier: identifier,
            title: data.metadata.title || identifier,
            creator: data.metadata.creator || "Unknown",
            publicdate: data.metadata.publicdate || "N/A",
            mediatype: data.metadata.mediatype || "unknown",
            description: data.metadata.description || "No description",
            subject: data.metadata.subject || []
          };
          
          metadataCache.set(identifier, metadata);
          return metadata;
        }
      } catch (error) {
        console.error(`Error fetching metadata for ${identifier}:`, error);
      }
      
      // Fallback: return basic metadata
      const fallbackMetadata = {
        identifier: identifier,
        title: identifier,
        creator: "Unknown",
        publicdate: "N/A",
        mediatype: "unknown",
        description: "No description available",
        subject: []
      };
      
      metadataCache.set(identifier, fallbackMetadata);
      return fallbackMetadata;
    }

    function createCard(identifier, metadata, username = null, isIdentifierItem = false) {
      const title = metadata.title || identifier;
      const creator = metadata.creator || "Unknown";
      const date = metadata.publicdate || "N/A";
      const tags = metadata.subject ? (Array.isArray(metadata.subject) ? metadata.subject.join(", ") : metadata.subject.toString()).slice(0, 100) : "None";
      const mediaType = metadata.mediatype || "unknown";
      const description = metadata.description ? metadata.description.toString() : "No description";
      const reviewUrl = `https://archive.org/details/${identifier}#reviews`;
      
      // Modified: Add username=yanshun081 as the last parameter for identifiers
      const shareUrl = `https://yan-1-related-1.github.io/yan-1-website-shared-links-redirecting/archive-identifier-page-shared-links-redirecting.html?identifier=${identifier}` + 
        (username ? `&username=${username}` : `&username=yanshun081`);

      const card = document.createElement("div");
      card.className = "card";
      card.dataset.mediatype = mediaType;
      if (isIdentifierItem) {
        card.dataset.isIdentifier = "true";
      }

      let metaHtml = `
        <div class="title">${title}</div>
        <div class="preview-container"
             data-identifier="${identifier}"
             data-mediatype="${mediaType}">
          <div class="preview-placeholder">Loading thumbnail‚Ä¶</div>
        </div>
        <div class="meta"><b>Creator:</b> ${creator}</div>
      `;

      // Only show username if provided (for profile items)
      if (username) {
        metaHtml += `<div class="username-meta"><b>Username:</b> @${username}</div>`;
      }

      metaHtml += `
        <div class="meta"><b>Date:</b> ${date}</div>
        <div class="meta"><b>Tags:</b> ${tags}</div>
        <div class="meta"><b>Media:</b> ${mediaType}</div>
      `;

      metaHtml += `
        <div class="description-full">${description}</div>
        <div class="meta">
          <a href="${reviewUrl}" target="_blank" class="reviews-link">Reviews</a>
        </div>
        <div class="card-actions">
          <button class="open-btn">Open Item</button>
          <button class="share-btn" data-share-url="${shareUrl}">·Øì‚û§</button>
        </div>
      `;

      card.innerHTML = metaHtml;

      card.querySelector(".open-btn").onclick = () => {
        // Open direct page in iframe instead of embed
        openFullscreen(`https://archive.org/details/${identifier}`);
      };

      card.querySelector(".share-btn").onclick = (e) => {
        const shareUrl = e.target.dataset.shareUrl;
        // Check if Web Share API is available
        if (navigator.share) {
          navigator.share({
            title: title,
            url: shareUrl
          }).catch(console.error);
        } else {
          // Fallback to clipboard
          navigator.clipboard.writeText(shareUrl).then(() => {
            alert("Share link copied to clipboard!");
          }).catch(err => {
            console.error('Failed to copy: ', err);
            // Fallback prompt
            prompt("Copy this link to share:", shareUrl);
          });
        }
      };

      // Store item for filtering
      const itemData = {
        element: card,
        mediatype: mediaType,
        isIdentifier: isIdentifierItem
      };
      allItems.push(itemData);
      
      // Observe thumbnail for lazy loading
      const preview = card.querySelector(".preview-container");
      thumbnailObserver.observe(preview);
      
      return itemData;
    }

    // Function to fetch identifiers from identifiers.json
    async function fetchIdentifiers() {
      try {
        const response = await fetch('identifiers.json');
        const identifiers = await response.json();
        return Array.isArray(identifiers) ? identifiers : [];
      } catch (error) {
        console.error('Error fetching identifiers:', error);
        return [];
      }
    }

    // Function to create identifier items and store them
    async function createIdentifierItems() {
      const identifiers = await fetchIdentifiers();
      
      if (identifiers.length === 0) {
        console.log('No identifiers found');
        return;
      }
      
      // Combine identifiers from identifiers.json with API identifiers
      allIdentifiers = [...new Set([...allIdentifiers, ...identifiers])];
      
      // Create identifier items and store them
      for (const identifier of allIdentifiers) {
        try {
          const metadata = await fetchIdentifierMetadata(identifier);
          const itemData = createCard(identifier, metadata, null, true);
          identifierItems.push(itemData);
        } catch (error) {
          console.error(`Failed to create identifier item for ${identifier}:`, error);
        }
      }
    }

    // Pick next 3 identifiers sequentially
    function getNextIdentifiers(count = 3) {
      if (identifierItems.length === 0) return [];
      
      const selected = [];
      for (let i = 0; i < count && identifierIndex < identifierItems.length; i++) {
        selected.push(identifierItems[identifierIndex]);
        identifierIndex++;
      }
      
      return selected;
    }

    function renderAccountItems(profileUrl, result) {
      const state = accountState[profileUrl];
      const items = result.docs;
      const username = result.username;
      
      // Create cards for all items
      const newCards = [];
      items.forEach((meta, index) => {
        const identifier = meta.identifier;
        const itemData = createCard(identifier, meta, username, false);
        newCards.push(itemData);
        grid.appendChild(itemData.element);
        loadedCount++;
      });

      // Insert next 3 identifiers from identifiers.json
      const nextIdentifiers = getNextIdentifiers(items.length);
      nextIdentifiers.forEach((itemData, index) => {
        if (newCards[index]) {
          newCards[index].element.after(itemData.element);
          loadedCount++;
        }
      });
      
      // Show load more button if we've loaded initial batch
      if (loadedCount >= ITEMS_PER_LOAD) {
        loadMoreBtn.classList.remove("hidden");
      }
    }

    function filterItems() {
      const filterValue = currentFilter;
      
      allItems.forEach(item => {
        if (filterValue === "all" || item.mediatype === filterValue) {
          item.element.style.display = "flex";
        } else {
          item.element.style.display = "none";
        }
      });
    }

    // Load more items function
    async function loadMoreItems() {
      status.textContent = "Loading more content‚Ä¶";
      loadMoreBtn.disabled = true;
      
      let loadedInThisBatch = 0;
      
      // Load profile items
      while (loadedInThisBatch < 3) {
        const account = pickRandomAccount();
        const result = await fetchThreeLatest(account);
        
        if (result) {
          renderAccountItems(account, result);
          loadedInThisBatch += result.docs.length;
        }
        
        // Small delay to prevent overwhelming the API
        await new Promise(r => setTimeout(r, 100));
      }
      
      status.textContent = "";
      loadMoreBtn.disabled = false;
    }

    async function initialLoad() {
      // Start loading identifiers in background (no await)
      await createIdentifierItems();
      
      status.textContent = "Loading content‚Ä¶";
      
      // Load initial 3 items immediately
      let initialLoaded = 0;
      
      while (initialLoaded < 3 && profileUrls.length > 0) {
        const account = pickRandomAccount();
        const result = await fetchThreeLatest(account);
        
        if (result) {
          renderAccountItems(account, result);
          initialLoaded += result.docs.length;
        }
      }
      
      status.textContent = "";
    }

    // Fullscreen functionality
    function openFullscreen(url) {
      // Create overlay
      const overlay = document.createElement("div");
      overlay.className = "fullscreen-overlay";
      
      // Create close button
      const closeBtn = document.createElement("button");
      closeBtn.className = "close-btn";
      closeBtn.innerHTML = "‚úï";
      closeBtn.onclick = () => {
        document.body.removeChild(overlay);
      };
      
      // Create embed container
      const embedContainer = document.createElement("div");
      embedContainer.className = "embed-container";
      embedContainer.innerHTML = `<iframe src="${url}" allowfullscreen></iframe>`;
      
      // Assemble and add to body
      overlay.appendChild(closeBtn);
      overlay.appendChild(embedContainer);
      document.body.appendChild(overlay);
    }

    // Event listeners
    filterBtn.addEventListener("click", () => {
      currentFilter = mediatypeSelect.value;
      filterItems();
    });
    
    loadMoreBtn.addEventListener("click", loadMoreItems);

    // Initialize
    initialLoad().catch(err => {
      console.error(err);
      status.textContent = "Error while loading content.";
    });
  </script>

</body>
</html>
